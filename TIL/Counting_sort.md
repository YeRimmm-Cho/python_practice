# 파이썬 정렬 알고리즘 – 카운팅 정렬 (Counting Sort)

## 1. 카운팅 정렬

- 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 방식

## 2. 핵심 아이디어

- 누적합 ⇒ 정렬된 위치를 알 수 있음
- 카운팅 배열을 만들면 ⇒ 나보다 작은 것의 개수를 구할 수 있음
    - 누적합 배열을 만들면 나보다 작은 것의 개수를 바로 구할 수 있음 (한 번에)
    - 누적합 배열 ⇒ 그 숫자의 정렬된 위치를 나타냄

- 누적합 배열에서의 의미: 해당 숫자(인덱스)의 정렬되었을 때 상대적 위치 → 정렬되었을 때 몇 번째 위치하고 있느냐
    - 만약 똑같은 숫자가 여러 개라면 마지막 숫자의 위치
- 상대적 위치: 1부터 시작 ⇒ 인덱스로 나타내려면 -1을 해줘야 함

## 3. 제한 사항

- 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능
- 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 함

## 4. 시간 복잡도

- O(n + k): n은 리스트 길이, k는 정수의 최댓값
- 선형시간

## 5. 계수 정렬 과정 예시

예시 데이터: `[0, 4, 1, 3, 1, 2, 4, 1]`

### 1단계: 카운트 배열 생성

- DATA에서 각 항목들의 발생 횟수를 세고, 정수 항목들로 직접 인덱스 되는 카운트 배열 COUNTS에 저장한다.

### 2단계: 누적합 변환

- 정렬된 집합에서 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 COUNTS의 원소를 조정한다.

### 3단계: 정렬 결과 TEMP에 채움

- DATA의 마지막 원소부터 하나씩 꺼내서 해당 위치에 삽입하고 COUNTS 값을 감소시킨다.

## 6. 파이썬 구현

```python
def counting_sort(DATA, TEMP, k):
    # DATA [] -- 입력 배열(0 to k)
    # TEMP [] -- 정렬된 배열.
    # COUNTS [] -- 카운트 배열.

    COUNTS = [0] * (k + 1)  # 인덱스 고려해서 k+1칸 준비

    for i in range(0, len(DATA)):  # 1단계: 등장 횟수 카운트
        COUNTS[DATA[i]] += 1

    for i in range(1, k + 1):  # 2단계: 누적합 계산
        COUNTS[i] += COUNTS[i - 1]

    for i in range(len(TEMP) - 1, -1, -1):  # 3단계: 뒤에서부터 정렬
        COUNTS[DATA[i]] -= 1
        TEMP[COUNTS[DATA[i]]] = DATA[i]

arr = [0, 4, 1, 3, 1, 2, 4, 1]
tmp = [0] * len(arr)
counting_sort(arr, tmp, 5)
print(tmp)  # 출력: [0, 1, 1, 1, 2, 3, 4, 4]
```

## 7. 장단점

### ✅ 장점

- 구현이 비교적 단순함
- O(n + k)의 선형 시간 복잡도
- 안정 정렬 가능 (같은 값의 원래 순서 유지)

### ⚠️ 단점

- 정수만 가능 (음수/실수는 보정 필요)
- 값의 범위(k)가 크면 메모리 비효율 발생
- 희소하거나 큰 범위의 데이터에는 부적합